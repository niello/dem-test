
Targets
{
	DS //???or declare color targets and depth-stencil resources separately? 
	{
		//dimensions
		//???format?
		//or declare like: BitsRed = 8 BitsGreen = 8 BitsBlue = 8 Type = 'int' Order = 'rgba'
		//BitsDepth = 32 BitsStencil = 0
		// etc
		UseAsSource = true	// Usage - SRV //???always?
		UseAsTarget = true	// Usage - RT or DS //???always?
		WidthRel = 1.0
		HeightRel = 1.0
	}
	
	ShadowMap
	{
		//dimensions
		//???format?
		//array size
		UseAsSource = true	// Usage - SRV //???always?
		UseAsTarget = true	// Usage - RT or DS //???always?
		Width = 2048	//!!!must be tuneable through settings! store name of the setting global variable?
		Height = 2048
	}
}

State //!!!construct state only if there is a final state block with no override!
{
	// Rasterizer
	ScissorTest = false
	//int CullMode = 2;

	// Blend
	AlphaBlend = false

	// Depth-stencil
	DepthTest = true
	DepthFunc = 'LessEqual'
	StencilTest = false
}

//???declare by name here, use in shader, bind through shader reflection?
//???or write like this: Const = 0, ChangeOnResize = null, PerFrame = 'CBPerFrame', using either number for a
//register numbar, name for resolve through the reflection, or null for 'not used'
//can even use arrays Const = [ 0, 'AdditionalConstants' ]
//Values is another problem. Consts can be set here, things like setting VP matrix on resize must be implemented
//in C++, only some binding of 'that var receives special value - VP matrix' may exist
Variables
{
	//Const {}
	//ChangeOnResize {}
	//PerFrame {}
}

Phases
{
//???TransformGeometry? - pre-transform with stream-output, later use bypass vertex shader? skinned will benefit, instanced probably won't

	Depth
	{
	//???in batches?
		//Shader = 'Depth' // Overrides object shaders

		Targets
		{
			Color = []
			DepthStecil = 'DS'
		}

		State
		{
			// Depth-stencil
			DepthWrite = true
		}
		
		Batches
		{
		//???or these are techs? can set tech flags!
			Shader = 'Depth' // Overrides object shaders
			Shader = 'Depth_ATest' // Overrides object shaders
			Shader = 'Depth_CDLODTerrain' // Overrides object shaders
			// Geometry - Solid
			// Geometry - ATest
			// Terrain //???or before ATest? what about early-Z?
			 //note that shader Depth must have tech for terrain! So it may be constructed from multiple sources!
		}
	}
	
	OcclusionCulling //!!!use CHC++!
	{
		Targets
		{
			Color = []
			DepthStecil = 'DS'
		}

		State
		{
			// Blend
			ColorWriteMask = 0
			
			// Depth-stencil
			DepthWrite = false
		}

		//render AABBs using a depth shader to test against the depth buffer, use queries
		
		Batches
		{
		// occlusion renderers
		// or implement occlusion as phase, not as renderer?
		}
	}
	
	PSSM
	{
		Targets
		{
			Color = []
			DepthStecil = 'ShadowMap'
		}
		
		//PSSM settings like a split count

		//from each light, gather visible objects who are shadow casters
		//construct tightest possible frustum for each split
		//render shadow map
	}

	Color // can be split to float PreHDR and displayable HDR
	{
		Targets
		{
			Color = [ 'SYS_BackBuffer' ] //???specify default backbuffer format right in this desc?
			DepthStecil = 'DS'
		}

		State
		{
			// Blend
			ColorWriteMask = 0xffffffff //???if channel can be only enabled or disabled, mb no need in 0xff etc, use single bit per channel?
			
			// Depth-stencil
			DepthWrite = false
		}
		
		Batches
		{
			// Opaque - alpha-blend disabled
			// ATest - alpha-blend disabled float AlphaRef = 0.5;
			// Terrain
			// Skybox //???is there any trick to fill only pixels not filled without much testing?
			// Alpha
			
			// Debug shapes:
			//AlphaBlendEnable	= True;
			//AlphaTestEnable		= False;
			//CullMode			= None; //CW;
			//SrcBlend			= SrcAlpha;
			//DestBlend			= InvSrcAlpha;
			//ZEnable				= False; //True;
			//ZFunc				= LessEqual;
			//ZWriteEnable		= False;
		}
	}
}
