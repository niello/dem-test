
Targets
{
	DS //???or declare color targets and depth-stencil resources separately? 
	{
		//dimensions
		//???format?
		//or declare like: BitsRed = 8 BitsGreen = 8 BitsBlue = 8 Type = 'int' Order = 'rgba'
		//BitsDepth = 32 BitsStencil = 0
		// etc
		UseAsSource = true	// Usage - SRV //???always?
		UseAsTarget = true	// Usage - RT or DS //???always?
		WidthRel = 1.0
		HeightRel = 1.0
	}
	
	ShadowMap
	{
		//dimensions
		//???format?
		//array size
		UseAsSource = true	// Usage - SRV //???always?
		UseAsTarget = true	// Usage - RT or DS //???always?
		Width = 2048	//!!!must be tuneable through settings! store name of the setting global variable?
		Height = 2048
	}
}

State //!!!construct state only if there is a final state block with no override!
{
	// Rasterizer
	ScissorTest = false

	// Blend
	AlphaBlend = false

	// Depth-stencil
	DepthTest = true
	DepthFunc = 'LessEqual'
	StencilTest = false
}

//???declare by name here, use in shader, bind through shader reflection?
//???or write like this: Const = 0, ChangeOnResize = null, PerFrame = 'CBPerFrame', using either number for a
//register numbar, name for resolve through the reflection, or null for 'not used'
//can even use arrays Const = [ 0, 'AdditionalConstants' ]
//Values is another problem. Consts can be set here, things like setting VP matrix on resize must be implemented
//in C++, only some binding of 'that var receives special value - VP matrix' may exist
Variables
{
	//Const {}
	//ChangeOnResize {}
	//PerFrame {}
}

Phases
{
	Depth
	{
		Shader = 'Depth' // Overrides object shaders

		Targets
		{
			Color = []
			DepthStecil = 'DS'
		}

		State
		{
			// Blend
			ColorWriteMask = 0
			
			// Depth-stencil
			DepthWrite = true
		}
		
		Batches
		{
			// Geometry - Solid
			// Geometry - ATest
			// Terrain //!!!note that shader Depth must have tech for terrain! So it may be constructed from multiple sources!
		}
	}
	
	OcclusionCulling //!!!use CHC++!
	{
		Targets
		{
			Color = []
			DepthStecil = 'DS'
		}

		State
		{
			// Blend
			ColorWriteMask = 0
			
			// Depth-stencil
			DepthWrite = false
		}

		//render AABBs using a depth shader to test against the depth buffer, use queries
		
		Batches
		{
		// occlusion renderers
		// or implement occlusion as phase, not as renderer?
		}
	}
	
	PSSM
	{
		Targets
		{
			Color = []
			DepthStecil = 'ShadowMap'
		}
		
		//PSSM settings like a split count

		//from each light, gather visible objects who are shadow casters
		//construct tightest possible frustum for each split
		//render shadow map
	}

	Color // can be split to float PreHDR and displayable HDR
	{
		Targets
		{
			Color = [ 'SYS_BackBuffer' ] //???specify default backbuffer format right in this desc?
			DepthStecil = 'DS'
		}

		State
		{
			// Blend
			ColorWriteMask = 0xffffffff
			
			// Depth-stencil
			DepthWrite = false
		}
		
		Batches
		{}
	}
}
